!function (o) { "object" == typeof module && module.exports ? module.exports = o.default = o : "function" == typeof define && define.amd ? define("highcharts/modules/heatmap", ["highcharts"], function (t) { return o(t), o.Highcharts = t, o }) : o("undefined" != typeof Highcharts ? Highcharts : void 0) }(function (t) { function o(t, o, e, i) { t.hasOwnProperty(o) || (t[o] = i.apply(null, e)) } o(t = t ? t._modules : {}, "Mixins/ColorSeries.js", [], function () { return { colorPointMixin: { setVisible: function (t) { var o = this, e = t ? "show" : "hide"; o.visible = o.options.visible = !!t, ["graphic", "dataLabel"].forEach(function (t) { o[t] && o[t][e]() }), this.series.buildKDTree() } }, colorSeriesMixin: { optionalAxis: "colorAxis", colorAxis: 0, translateColors: function () { var e = this, i = this.options.nullColor, s = this.colorAxis, r = this.colorKey; (this.data.length ? this.data : this.points).forEach(function (t) { var o = t.getNestedProperty(r); (o = t.options.color || (t.isNull || null === t.value ? i : s && void 0 !== o ? s.toColor(o, t) : t.color || e.color)) && t.color !== o && (t.color = o, "point" === e.options.legendType && t.legendItem && e.chart.legend.colorizeItem(t, t.visible)) }) } } } }), o(t, "Core/Axis/ColorAxis.js", [t["Core/Axis/Axis.js"], t["Core/Chart/Chart.js"], t["Core/Color/Color.js"], t["Mixins/ColorSeries.js"], t["Core/Animation/Fx.js"], t["Core/Globals.js"], t["Core/Legend.js"], t["Mixins/LegendSymbol.js"], t["Core/Color/Palette.js"], t["Core/Series/Point.js"], t["Core/Series/Series.js"], t["Core/Utilities.js"]], function (t, o, e, i, s, r, a, d, n, l, h, p) { var c, u = this && this.__extends || (c = function (t, o) { return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, o) { t.__proto__ = o } || function (t, o) { for (var e in o) o.hasOwnProperty(e) && (t[e] = o[e]) })(t, o) }, function (t, o) { function e() { this.constructor = t } c(t, o), t.prototype = null === o ? Object.create(o) : (e.prototype = o.prototype, new e) }), y = e.parse; e = i.colorPointMixin, i = i.colorSeriesMixin; var f = r.noop, g = p.addEvent, m = p.erase, x = p.extend, v = p.isNumber, C = p.merge, b = p.pick, M = p.splat; x(h.prototype, i), x(l.prototype, e), o.prototype.collectionsWithUpdate.push("colorAxis"), o.prototype.collectionsWithInit.colorAxis = [o.prototype.addColorAxis]; var A, P = (u(S, A = t), S.prototype.init = function (t, o) { var e = t.options.legend || {}, i = o.layout ? "vertical" !== o.layout : "vertical" !== e.layout, e = C(S.defaultOptions, o, { showEmpty: !1, title: null, visible: e.enabled && (!o || !1 !== o.visible) }); this.coll = "colorAxis", this.side = o.side || i ? 2 : 1, this.reversed = o.reversed || !i, this.opposite = !i, t.options[this.coll] = e, A.prototype.init.call(this, t, e), o.dataClasses && this.initDataClasses(o), this.initStops(), this.horiz = i, this.zoomEnabled = !1 }, S.prototype.initDataClasses = function (t) { var e, i = this.chart, s = 0, r = i.options.chart.colorCount, a = this.options, n = t.dataClasses.length; this.dataClasses = e = [], this.legendItems = [], t.dataClasses.forEach(function (t, o) { t = C(t), e.push(t), !i.styledMode && t.color || ("category" === a.dataClassColor ? (i.styledMode || (o = i.options.colors, r = o.length, t.color = o[s]), t.colorIndex = s, ++s === r && (s = 0)) : t.color = y(a.minColor).tweenTo(y(a.maxColor), n < 2 ? .5 : o / (n - 1))) }) }, S.prototype.hasData = function () { return !!(this.tickPositions || []).length }, S.prototype.setTickPositions = function () { if (!this.dataClasses) return A.prototype.setTickPositions.call(this) }, S.prototype.initStops = function () { this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]], this.stops.forEach(function (t) { t.color = y(t[1]) }) }, S.prototype.setOptions = function (t) { A.prototype.setOptions.call(this, t), this.options.crosshair = this.options.marker }, S.prototype.setAxisSize = function () { var t, o, e = this.legendSymbol, i = this.chart, s = i.options.legend || {}; e ? (this.left = s = e.attr("x"), this.top = t = e.attr("y"), this.width = o = e.attr("width"), this.height = e = e.attr("height"), this.right = i.chartWidth - s - o, this.bottom = i.chartHeight - t - e, this.len = this.horiz ? o : e, this.pos = this.horiz ? s : t) : this.len = (this.horiz ? s.symbolWidth : s.symbolHeight) || S.defaultLegendLength }, S.prototype.normalizedValue = function (t) { return this.logarithmic && (t = this.logarithmic.log2lin(t)), 1 - (this.max - t) / (this.max - this.min || 1) }, S.prototype.toColor = function (t, o) { var e, i = this.dataClasses, s = this.stops; if (i) for (e = i.length; e--;) { var r = i[e], a = r.from, s = r.to; if ((void 0 === a || a <= t) && (void 0 === s || t <= s)) { var n = r.color; o && (o.dataClass = e, o.colorIndex = r.colorIndex); break } } else { for (t = this.normalizedValue(t), e = s.length; e-- && !(t > s[e][0]);); a = s[e] || s[e + 1], t = 1 - ((s = s[e + 1] || a)[0] - t) / (s[0] - a[0] || 1), n = a.color.tweenTo(s.color, t) } return n }, S.prototype.getOffset = function () { var t = this.legendGroup, o = this.chart.axisOffset[this.side]; t && (this.axisParent = t, A.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = o) }, S.prototype.setLegendColor = function () { var t = (o = this.reversed) ? 1 : 0, o = o ? 0 : 1, t = this.horiz ? [t, 0, o, 0] : [0, o, 0, t]; this.legendColor = { linearGradient: { x1: t[0], y1: t[1], x2: t[2], y2: t[3] }, stops: this.stops } }, S.prototype.drawLegendSymbol = function (t, o) { var e = t.padding, i = t.options, s = this.horiz, r = b(i.symbolWidth, s ? S.defaultLegendLength : 12), a = b(i.symbolHeight, s ? 12 : S.defaultLegendLength), n = b(i.labelPadding, s ? 16 : 30), i = b(i.itemDistance, 10); this.setLegendColor(), o.legendSymbol = this.chart.renderer.rect(0, t.baseline - 11, r, a).attr({ zIndex: 1 }).add(o.legendGroup), this.legendItemWidth = r + e + (s ? i : n), this.legendItemHeight = a + e + (s ? n : 0) }, S.prototype.setState = function (o) { this.series.forEach(function (t) { t.setState(o) }) }, S.prototype.setVisible = function () { }, S.prototype.getSeriesExtremes = function () { var t, o = this.series, e = o.length; for (this.dataMin = 1 / 0, this.dataMax = -1 / 0; e--;) { var i = o[e], s = i.colorKey = b(i.options.colorKey, i.colorKey, i.pointValKey, i.zoneAxis, "y"), r = i.pointArrayMap, a = i[s + "Min"] && i[s + "Max"]; if (i[s + "Data"]) var n = i[s + "Data"]; else if (r) { n = [], r = r.indexOf(s); var l = i.yData; if (0 <= r && l) for (t = 0; t < l.length; t++)n.push(b(l[t][r], l[t])) } else n = i.yData; a ? (i.minColorValue = i[s + "Min"], i.maxColorValue = i[s + "Max"]) : (n = h.prototype.getExtremes.call(i, n), i.minColorValue = n.dataMin, i.maxColorValue = n.dataMax), void 0 !== i.minColorValue && (this.dataMin = Math.min(this.dataMin, i.minColorValue), this.dataMax = Math.max(this.dataMax, i.maxColorValue)), a || h.prototype.applyExtremes.call(i) } }, S.prototype.drawCrosshair = function (t, o) { var e, i = o && o.plotX, s = o && o.plotY, r = this.pos, a = this.len; o && ((e = this.toPixels(o.getNestedProperty(o.series.colorKey))) < r ? e = r - 2 : r + a < e && (e = r + a + 2), o.plotX = e, o.plotY = this.len - e, A.prototype.drawCrosshair.call(this, t, o), o.plotX = i, o.plotY = s, this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass("highcharts-coloraxis-marker").add(this.legendGroup), this.cross.addedToColorAxis = !0, !this.chart.styledMode && this.crosshair && this.cross.attr({ fill: this.crosshair.color }))) }, S.prototype.getPlotLinePath = function (t) { var o = this.left, e = t.translatedValue, i = this.top; return v(e) ? this.horiz ? [["M", e - 4, i - 6], ["L", e + 4, i - 6], ["L", e, i], ["Z"]] : [["M", o, e], ["L", o - 6, e + 6], ["L", o - 6, e - 6], ["Z"]] : A.prototype.getPlotLinePath.call(this, t) }, S.prototype.update = function (t, o) { var e = this.chart.legend; this.series.forEach(function (t) { t.isDirtyData = !0 }), (t.dataClasses && e.allItems || this.dataClasses) && this.destroyItems(), A.prototype.update.call(this, t, o), this.legendItem && (this.setLegendColor(), e.colorizeItem(this, !0)) }, S.prototype.destroyItems = function () { var o = this.chart; this.legendItem ? o.legend.destroyItem(this) : this.legendItems && this.legendItems.forEach(function (t) { o.legend.destroyItem(t) }), o.isDirtyLegend = !0 }, S.prototype.destroy = function () { this.chart.isDirtyLegend = !0, this.destroyItems(), A.prototype.destroy.apply(this, [].slice.call(arguments)) }, S.prototype.remove = function (t) { this.destroyItems(), A.prototype.remove.call(this, t) }, S.prototype.getDataClassLegendSymbols = function () { var a, n = this, l = n.chart, h = n.legendItems, t = l.options.legend, p = t.valueDecimals, c = t.valueSuffix || ""; return h.length || n.dataClasses.forEach(function (t, o) { var e = !0, i = t.from, s = t.to, r = l.numberFormatter; a = "", void 0 === i ? a = "< " : void 0 === s && (a = "> "), void 0 !== i && (a += r(i, p) + c), void 0 !== i && void 0 !== s && (a += " - "), void 0 !== s && (a += r(s, p) + c), h.push(x({ chart: l, name: a, options: {}, drawLegendSymbol: d.drawRectangle, visible: !0, setState: f, isDataClass: !0, setVisible: function () { e = n.visible = !e, n.series.forEach(function (t) { t.points.forEach(function (t) { t.dataClass === o && t.setVisible(e) }) }), l.legend.colorizeItem(this, e) } }, t)) }), h }, S.defaultLegendLength = 200, S.defaultOptions = { lineWidth: 0, minPadding: 0, maxPadding: 0, gridLineWidth: 1, tickPixelInterval: 72, startOnTick: !0, endOnTick: !0, offset: 0, marker: { animation: { duration: 50 }, width: .01, color: n.neutralColor40 }, labels: { overflow: "justify", rotation: 0 }, minColor: n.highlightColor10, maxColor: n.highlightColor100, tickLength: 5, showInLegend: !0 }, S.keepProps = ["legendGroup", "legendItemHeight", "legendItemWidth", "legendItem", "legendSymbol"], S); function S(t, o) { var e = A.call(this, t, o) || this; return e.beforePadding = !1, e.chart = void 0, e.coll = "colorAxis", e.dataClasses = void 0, e.legendItem = void 0, e.legendItems = void 0, e.name = "", e.options = void 0, e.stops = void 0, e.visible = !0, e.init(t, o), e } return Array.prototype.push.apply(t.keepProps, P.keepProps), r.ColorAxis = P, ["fill", "stroke"].forEach(function (t) { s.prototype[t + "Setter"] = function () { this.elem.attr(t, y(this.start).tweenTo(y(this.end), this.pos), null, !0) } }), g(o, "afterGetAxes", function () { var e = this, t = e.options; this.colorAxis = [], t.colorAxis && (t.colorAxis = M(t.colorAxis), t.colorAxis.forEach(function (t, o) { t.index = o, new P(e, t) })) }), g(h, "bindAxes", function () { var t = this.axisTypes; t ? -1 === t.indexOf("colorAxis") && t.push("colorAxis") : this.axisTypes = ["colorAxis"] }), g(a, "afterGetAllItems", function (o) { var e, t, i = []; for ((this.chart.colorAxis || []).forEach(function (t) { (e = t.options) && e.showInLegend && (e.dataClasses && e.visible ? i = i.concat(t.getDataClassLegendSymbols()) : e.visible && i.push(t), t.series.forEach(function (t) { t.options.showInLegend && !e.dataClasses || ("point" === t.options.legendType ? t.points.forEach(function (t) { m(o.allItems, t) }) : m(o.allItems, t)) })) }), t = i.length; t--;)o.allItems.unshift(i[t]) }), g(a, "afterColorizeItem", function (t) { t.visible && t.item.legendColor && t.item.legendSymbol.attr({ fill: t.item.legendColor }) }), g(a, "afterUpdate", function () { var t = this.chart.colorAxis; t && t.forEach(function (t, o, e) { t.update({}, e) }) }), g(h, "afterTranslate", function () { (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors() }), P }), o(t, "Mixins/ColorMapSeries.js", [t["Core/Globals.js"], t["Core/Series/Point.js"], t["Core/Utilities.js"]], function (t, o, e) { var i = e.defined; return { colorMapPointMixin: { dataLabelOnNull: !0, isValid: function () { return null !== this.value && 1 / 0 !== this.value && -1 / 0 !== this.value }, setState: function (t) { o.prototype.setState.call(this, t), this.graphic && this.graphic.attr({ zIndex: "hover" === t ? 1 : 0 }) } }, colorMapSeriesMixin: { pointArrayMap: ["value"], axisTypes: ["xAxis", "yAxis", "colorAxis"], trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], getSymbol: t.noop, parallelArrays: ["x", "y", "value"], colorKey: "value", pointAttribs: t.seriesTypes.column.prototype.pointAttribs, colorAttribs: function (t) { var o = {}; return i(t.color) && (o[this.colorProp || "fill"] = t.color), o } } } }), o(t, "Series/Heatmap/HeatmapPoint.js", [t["Mixins/ColorMapSeries.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Utilities.js"]], function (t, o, e) { var i, s = this && this.__extends || (i = function (t, o) { return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, o) { t.__proto__ = o } || function (t, o) { for (var e in o) o.hasOwnProperty(e) && (t[e] = o[e]) })(t, o) }, function (t, o) { function e() { this.constructor = t } i(t, o), t.prototype = null === o ? Object.create(o) : (e.prototype = o.prototype, new e) }); t = t.colorMapPointMixin; var r, a = e.clamp, n = e.extend, p = e.pick; function l() { var t = null !== r && r.apply(this, arguments) || this; return t.options = void 0, t.series = void 0, t.value = void 0, t.x = void 0, t.y = void 0, t } return r = o.seriesTypes.scatter.prototype.pointClass, s(l, r), l.prototype.applyOptions = function (t, o) { return (t = r.prototype.applyOptions.call(this, t, o)).formatPrefix = t.isNull || null === t.value ? "null" : "point", t }, l.prototype.getCellAttributes = function () { var t = (r = this.series).options, o = (t.colsize || 1) / 2, e = (t.rowsize || 1) / 2, i = r.xAxis, s = r.yAxis, n = this.options.marker || r.options.marker, r = r.pointPlacementToXValue(), l = p(this.pointPadding, t.pointPadding, 0), h = { x1: a(Math.round(i.len - (i.translate(this.x - o, !1, !0, !1, !0, -r) || 0)), -i.len, 2 * i.len), x2: a(Math.round(i.len - (i.translate(this.x + o, !1, !0, !1, !0, -r) || 0)), -i.len, 2 * i.len), y1: a(Math.round(s.translate(this.y - e, !1, !0, !1, !0) || 0), -s.len, 2 * s.len), y2: a(Math.round(s.translate(this.y + e, !1, !0, !1, !0) || 0), -s.len, 2 * s.len) }; return [["width", "x"], ["height", "y"]].forEach(function (t) { var o = t[0], e = (t = t[1]) + "1", i = t + "2", s = Math.abs(h[e] - h[i]), r = n && n.lineWidth || 0, a = Math.abs(h[e] + h[i]) / 2; n[o] && n[o] < s && (h[e] = a - n[o] / 2 - r / 2, h[i] = a + n[o] / 2 + r / 2), l && ("y" === t && (e = i, i = t + "1"), h[e] += l, h[i] -= l) }), h }, l.prototype.haloPath = function (t) { if (!t) return []; var o = this.shapeArgs; return ["M", o.x - t, o.y - t, "L", o.x - t, o.y + o.height + t, o.x + o.width + t, o.y + o.height + t, o.x + o.width + t, o.y - t, "Z"] }, l.prototype.isValid = function () { return 1 / 0 !== this.value && -1 / 0 !== this.value }, n((o = l).prototype, { dataLabelOnNull: t.dataLabelOnNull, setState: t.setState }), o }), o(t, "Series/Heatmap/HeatmapSeries.js", [t["Mixins/ColorMapSeries.js"], t["Core/Globals.js"], t["Series/Heatmap/HeatmapPoint.js"], t["Mixins/LegendSymbol.js"], t["Core/Color/Palette.js"], t["Core/Series/SeriesRegistry.js"], t["Core/Renderer/SVG/SVGRenderer.js"], t["Core/Utilities.js"]], function (t, n, o, e, i, s, r, a) { var l, h = this && this.__extends || (l = function (t, o) { return (l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, o) { t.__proto__ = o } || function (t, o) { for (var e in o) o.hasOwnProperty(e) && (t[e] = o[e]) })(t, o) }, function (t, o) { function e() { this.constructor = t } l(t, o), t.prototype = null === o ? Object.create(o) : (e.prototype = o.prototype, new e) }); t = t.colorMapSeriesMixin; var p, c = n.noop, d = s.series, u = s.seriesTypes, y = u.column, u = u.scatter, f = r.prototype.symbols, g = a.extend, m = a.fireEvent, x = a.isNumber, v = a.merge, C = a.pick; function b() { var t = null !== p && p.apply(this, arguments) || this; return t.colorAxis = void 0, t.data = void 0, t.options = void 0, t.points = void 0, t.valueMax = NaN, t.valueMin = NaN, t } return h(b, p = u), b.prototype.drawPoints = function () { var o = this; ((this.options.marker || {}).enabled || this._hasPointMarkers) && (d.prototype.drawPoints.call(this), this.points.forEach(function (t) { t.graphic && t.graphic[o.chart.styledMode ? "css" : "animate"](o.colorAttribs(t)) })) }, b.prototype.getExtremes = function () { var t = (o = d.prototype.getExtremes.call(this, this.valueData)).dataMin, o = o.dataMax; return x(t) && (this.valueMin = t), x(o) && (this.valueMax = o), d.prototype.getExtremes.call(this) }, b.prototype.getValidPoints = function (t, o) { return d.prototype.getValidPoints.call(this, t, o, !0) }, b.prototype.hasData = function () { return !!this.processedXData.length }, b.prototype.init = function () { d.prototype.init.apply(this, arguments); var t = this.options; t.pointRange = C(t.pointRange, t.colsize || 1), this.yAxis.axisPointRange = t.rowsize || 1, g(f, { ellipse: f.circle, rect: f.square }) }, b.prototype.markerAttribs = function (t, o) { var e, i, s = t.marker || {}, r = this.options.marker || {}, a = t.shapeArgs || {}, n = {}; return t.hasImage ? { x: t.plotX, y: t.plotY } : (o && (e = r.states[o] || {}, i = s.states && s.states[o] || {}, [["width", "x"], ["height", "y"]].forEach(function (t) { n[t[0]] = (i[t[0]] || e[t[0]] || a[t[0]]) + (i[t[0] + "Plus"] || e[t[0] + "Plus"] || 0), n[t[1]] = a[t[1]] + (a[t[0]] - n[t[0]]) / 2 })), o ? n : a) }, b.prototype.pointAttribs = function (t, o) { var e = d.prototype.pointAttribs.call(this, t, o), i = this.options || {}, s = (a = this.chart.options.plotOptions || {}).series || {}, r = a.heatmap || {}, a = i.borderColor || r.borderColor || s.borderColor, s = i.borderWidth || r.borderWidth || s.borderWidth || e["stroke-width"]; return e.stroke = t && t.marker && t.marker.lineColor || i.marker && i.marker.lineColor || a || this.color, e["stroke-width"] = s, o && (o = (t = v(i.states[o], i.marker && i.marker.states[o], t && t.options.states && t.options.states[o] || {})).brightness, e.fill = t.color || n.color(e.fill).brighten(o || 0).get(), e.stroke = t.lineColor), e }, b.prototype.setClip = function (t) { var o = this.chart; d.prototype.setClip.apply(this, arguments), !1 === this.options.clip && !t || this.markerGroup.clip((t || this.clipBox) && this.sharedClipKey ? o[this.sharedClipKey] : o.clipRect) }, b.prototype.translate = function () { var r = (t = this.options).marker && t.marker.symbol || "", a = f[r] ? r : "rect", t = this.options, n = -1 !== ["circle", "square"].indexOf(a); this.generatePoints(), this.points.forEach(function (t) { var o, e = t.getCellAttributes(), i = { x: Math.min(e.x1, e.x2), y: Math.min(e.y1, e.y2), width: Math.max(Math.abs(e.x2 - e.x1), 0), height: Math.max(Math.abs(e.y2 - e.y1), 0) }, s = t.hasImage = 0 === (t.marker && t.marker.symbol || r || "").indexOf("url"); n && (o = Math.abs(i.width - i.height), i.x = Math.min(e.x1, e.x2) + (i.width < i.height ? 0 : o / 2), i.y = Math.min(e.y1, e.y2) + (i.width < i.height ? o / 2 : 0), i.width = i.height = Math.min(i.width, i.height)), o = { plotX: (e.x1 + e.x2) / 2, plotY: (e.y1 + e.y2) / 2, clientX: (e.x1 + e.x2) / 2, shapeType: "path", shapeArgs: v(!0, i, { d: f[a](i.x, i.y, i.width, i.height) }) }, s && (t.marker = { width: i.width, height: i.height }), g(t, o) }), m(this, "afterTranslate") }, b.defaultOptions = v(u.defaultOptions, { animation: !1, borderWidth: 0, nullColor: i.neutralColor3, dataLabels: { formatter: function () { return this.point.value }, inside: !0, verticalAlign: "middle", crop: !1, overflow: !1, padding: 0 }, marker: { symbol: "rect", radius: 0, lineColor: void 0, states: { hover: { lineWidthPlus: 0 }, select: {} } }, clip: !0, pointRange: null, tooltip: { pointFormat: "{point.x}, {point.y}: {point.value}<br/>" }, states: { hover: { halo: !1, brightness: .2 } } }), g((r = b).prototype, { alignDataLabel: y.prototype.alignDataLabel, axisTypes: t.axisTypes, colorAttribs: t.colorAttribs, colorKey: t.colorKey, directTouch: !0, drawLegendSymbol: e.drawRectangle, getBox: c, getExtremesFromAll: !0, getSymbol: d.prototype.getSymbol, hasPointSpecificOptions: !0, parallelArrays: t.parallelArrays, pointArrayMap: ["y", "value"], pointClass: o, trackerGroups: t.trackerGroups }), s.registerSeriesType("heatmap", r), r }), o(t, "masters/modules/heatmap.src.js", [], function () { }) });